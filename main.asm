.386
.model flat

.code

@FUNC@20 proc
	push ebp ;сохраняем ebp при вызове
	mov ebp, esp ;устанавливаем новое значение ebp

	cmp ecx, 0
	je error

	cmp edx, 0
	je error

	; длина второй строки
	mov ebx, edx

	mov edi, [ebp]+8	;первая строка
	mov esi, [ebp]+12	;вторая строка
	
FindSymbol: ;ищем символ

	mov eax, 0
	mov al,[edi]	;берем символ первой строки 
	mov ah, [esi]	;берем символ второй строки
	cmp al, ah	;сравниваем два символа
	je found	;если символы равны, то переходим в found
	inc esi		; переходим на следующий символ второй строки
	dec ebx		;уменьшаем кол-во символов первой строки
	cmp ebx, 0	;проверяем закончились ли символы
	ja FindSymbol	;если символы еще есть, переходим к ним

	;символ из первой строки не нашелся, фиксируем его индекс
	mov eax, [ebp]+16
	pop ebp
	ret 12
found:
	;если нашли хотя бы одно вхождение символа, обрабатываем остальные символы дальше
	inc edi ;переходим на следующий символ первой строки
	mov esi, [ebp]+12	;возвращаем в регистр esi вторую строку, чтобы снова обработать ее в сравнении с другим символом
	mov ebx, edx	;возвращаем в переменную slenght максимальное кол-во символов второй строки	
	mov eax, [ebp]+16
	inc eax		; увеличиваем индекс первой строки
	mov [ebp]+16,eax
	dec ecx		;уменьшаем кол-во символов первой строки
	cmp ecx, 0	;проверяем закончились ли символы
	ja FindSymbol	;если не закончились, переходим к дальнейшему анализу
;все символы нашлись
	pop ebp
	mov eax, -1
	ret 12
error:
		pop ebp
		mov eax, -2
		ret 12
@FUNC@20 endp
end